<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Eruda Mobile Console -->
    <script src="https://cdn.jsdelivr.net/npm/eruda@3/eruda.min.js"></script>
    <script>
      if (typeof eruda !== "undefined") {
        eruda.init();
        if (/mobile|android|ios|iphone|ipad|ipod/i.test(navigator.userAgent.toLowerCase())) {
          eruda.show();
        }
      }
    </script>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* Pathfinding - Simple Visual Explanation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        
        h1 {
            color: #2c5aa0;
            text-align: center;
        }
        
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        #graph {
            width: 100%;
            height: 400px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .explanation {
            background: #e8f0fe;
            border-left: 4px solid #2c5aa0;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        
        .step-info {
            text-align: center;
            font-size: 18px;
            color: #333;
            margin: 20px 0;
            min-height: 30px;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-circle {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
        }
        
        .start-node { background: #ff9800; }
        .goal-node { background: #f44336; }
        .exploring { background: #feca57; }
        .visited { background: #b2dfdb; }
        .path { background: #4CAF50; }
        .unvisited { background: #e0e0e0; }
        
        .intro {
            text-align: center;
            color: #666;
            margin: 20px 0;
        }
        
        .score-display {
            background: #f0f0f0;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
            font-family: monospace;
        }
        
        .score-display h4 {
            margin: 0 0 10px 0;
            color: #666;
        }
        
        .back-link {
            color: #2c5aa0;
            text-decoration: none;
            margin-bottom: 20px;
            display: inline-block;
        }
        
        .back-link:hover {
            text-decoration: underline;
        }
        
        .code-section {
            margin-top: 30px;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .code-toggle {
            background: #666;
            color: white;
            border: none;
            padding: 5px 10px;
            font-size: 12px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .code-content {
            overflow: hidden;
            transition: max-height 0.3s ease;
            max-height: 1000px;
        }
        
        .code-content.collapsed {
            max-height: 0;
        }
        
        .node-label {
            font-size: 11px;
            font-weight: bold;
        }
        
        .heuristic-label {
            font-size: 9px;
            fill: #666;
        }
        
        .grid-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
        }
        
        .grid-info {
            text-align: center;
            color: #666;
        }
    </style>
</head>
<body>
    <a href="../../index.html" class="back-link">← Back to Examples</a>
    
    <h1>A* Pathfinding Explained</h1>
    
    <div class="container">
        <div class="intro">
            <p><strong>A* finds the shortest path by being smart about which nodes to explore first.</strong></p>
            <p>Like a GPS navigator, it uses knowledge about the destination to guide its search efficiently.</p>
        </div>
        
        <svg id="graph"></svg>
        
        <div class="grid-info">
            <small>Grid representation: Each cell is a node, diagonal movement allowed</small>
        </div>
        
        <div class="score-display" id="score-display" style="display: none;">
            <h4>Current Node Scores:</h4>
            <div id="score-content">
                <div>f(n) = g(n) + h(n)</div>
                <div>g(n) = Distance from start</div>
                <div>h(n) = Estimated distance to goal (heuristic)</div>
            </div>
        </div>
        
        <div class="step-info" id="step-info">Click "Find Path" to see how A* navigates from start to goal</div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-circle start-node"></div>
                <span>Start</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle goal-node"></div>
                <span>Goal</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle exploring"></div>
                <span>Exploring</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle visited"></div>
                <span>Visited</span>
            </div>
            <div class="legend-item">
                <div class="legend-circle path"></div>
                <span>Shortest Path</span>
            </div>
        </div>
        
        <div class="controls">
            <button id="find-btn" onclick="startPathfinding()">Find Path</button>
            <button id="reset-btn" onclick="resetVisualization()">Reset</button>
        </div>
        
        <div class="explanation">
            <h3>Key Concept:</h3>
            <p>A* is an intelligent pathfinding algorithm that combines the best of two worlds:</p>
            <ul>
                <li><strong>Dijkstra's guarantee:</strong> Always finds the shortest path</li>
                <li><strong>Greedy best-first efficiency:</strong> Uses a heuristic to search towards the goal</li>
                <li><strong>f(n) = g(n) + h(n):</strong> Total cost = actual cost + estimated remaining cost</li>
            </ul>
            <p>The heuristic function (h) estimates the distance to the goal. Common heuristics include Manhattan distance for grids and Euclidean distance for open spaces.</p>
        </div>
        
        <div class="code-section">
            <div class="code-header">
                <h3>Code Example</h3>
                <button class="code-toggle" id="code-toggle">Hide Code ▲</button>
            </div>
            <div class="code-content" id="code-content">
                <pre><code class="language-javascript" id="code-display">Loading code...</code></pre>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    
    <script type="module">
        // Import the A* pathfinding function
        import { runAStarPathfinding } from './astar.js';
        
        // Load and display the actual code
        async function loadCodeExample() {
            try {
                const response = await fetch('./astar.js');
                const code = await response.text();
                
                // Extract the main function for display
                const functionMatch = code.match(/export function runAStarPathfinding[\s\S]*?^}/m);
                if (functionMatch) {
                    document.getElementById('code-display').textContent = functionMatch[0];
                    Prism.highlightElement(document.getElementById('code-display'));
                } else {
                    document.getElementById('code-display').textContent = code;
                    Prism.highlightElement(document.getElementById('code-display'));
                }
            } catch (error) {
                document.getElementById('code-display').textContent = 
`// Example usage of A* pathfinding
import { astar } from '@graphty/algorithms';

// Create a graph with weighted edges
const graph = new Map([
    ['A', new Map([['B', 1], ['C', 4]])],
    ['B', new Map([['D', 2], ['E', 5]])],
    // ... more nodes
]);

// Define heuristic function (e.g., Euclidean distance)
function heuristic(node, goal) {
    // Return estimated distance to goal
}

// Find shortest path
const result = astar(graph, 'A', 'G', heuristic);
console.log('Path:', result.path);
console.log('Cost:', result.cost);`;
                Prism.highlightElement(document.getElementById('code-display'));
            }
        }
        
        // Grid configuration
        const GRID_SIZE = 10;
        const CELL_SIZE = 35;
        const GRID_PADDING = 50;
        
        // Create grid nodes
        const nodes = [];
        const nodeMap = new Map();
        
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                const id = `${x},${y}`;
                const node = {
                    id,
                    x: GRID_PADDING + x * CELL_SIZE + CELL_SIZE/2,
                    y: GRID_PADDING + y * CELL_SIZE + CELL_SIZE/2,
                    gridX: x,
                    gridY: y
                };
                nodes.push(node);
                nodeMap.set(id, node);
            }
        }
        
        // Define start and goal
        const startId = '1,1';
        const goalId = '8,8';
        
        // Some obstacles for more interesting pathfinding
        const obstacles = new Set(['3,3', '3,4', '3,5', '4,3', '5,3', '6,3', '6,4', '6,5']);
        
        let isRunning = false;
        let pathResult = null;
        
        // Initialize the graph visualization
        function initGraph() {
            const svg = document.getElementById('graph');
            svg.innerHTML = '';
            
            // Draw grid cells
            nodes.forEach(node => {
                if (!obstacles.has(node.id)) {
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', node.x - CELL_SIZE/2);
                    rect.setAttribute('y', node.y - CELL_SIZE/2);
                    rect.setAttribute('width', CELL_SIZE - 2);
                    rect.setAttribute('height', CELL_SIZE - 2);
                    rect.setAttribute('fill', node.id === startId ? '#ff9800' : 
                                             node.id === goalId ? '#f44336' : '#e0e0e0');
                    rect.setAttribute('stroke', '#999');
                    rect.setAttribute('stroke-width', '1');
                    rect.setAttribute('id', `cell-${node.id}`);
                    svg.appendChild(rect);
                    
                    // Add label for start and goal
                    if (node.id === startId || node.id === goalId) {
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', node.x);
                        text.setAttribute('y', node.y + 4);
                        text.setAttribute('text-anchor', 'middle');
                        text.setAttribute('class', 'node-label');
                        text.setAttribute('fill', 'white');
                        text.textContent = node.id === startId ? 'S' : 'G';
                        svg.appendChild(text);
                    }
                    
                    // Add heuristic labels (will be shown during algorithm)
                    const hText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    hText.setAttribute('x', node.x);
                    hText.setAttribute('y', node.y - 8);
                    hText.setAttribute('text-anchor', 'middle');
                    hText.setAttribute('class', 'heuristic-label');
                    hText.setAttribute('id', `h-${node.id}`);
                    hText.style.visibility = 'hidden';
                    svg.appendChild(hText);
                } else {
                    // Draw obstacles
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', node.x - CELL_SIZE/2);
                    rect.setAttribute('y', node.y - CELL_SIZE/2);
                    rect.setAttribute('width', CELL_SIZE - 2);
                    rect.setAttribute('height', CELL_SIZE - 2);
                    rect.setAttribute('fill', '#666');
                    rect.setAttribute('stroke', '#333');
                    rect.setAttribute('stroke-width', '1');
                    svg.appendChild(rect);
                }
            });
        }
        
        // Start the A* pathfinding visualization
        window.startPathfinding = async function() {
            if (isRunning) return;
            
            isRunning = true;
            document.getElementById('find-btn').disabled = true;
            document.getElementById('reset-btn').disabled = true;
            document.getElementById('score-display').style.display = 'block';
            
            // Reset all non-obstacle cells
            nodes.forEach(node => {
                if (!obstacles.has(node.id) && node.id !== startId && node.id !== goalId) {
                    document.getElementById(`cell-${node.id}`).setAttribute('fill', '#e0e0e0');
                }
            });
            
            // Run the actual algorithm
            const result = runAStarPathfinding(startId, goalId, obstacles);
            console.log('A* Pathfinding Result:', result);
            pathResult = result;
            
            // Animate the search process
            await animateSearch(result);
            
            isRunning = false;
            document.getElementById('reset-btn').disabled = false;
        }
        
        // Animate the A* search process
        async function animateSearch(result) {
            const stepInfo = document.getElementById('step-info');
            const scoreContent = document.getElementById('score-content');
            
            if (!result || !result.visited) {
                stepInfo.textContent = 'No path found!';
                return;
            }
            
            // Show heuristic values
            nodes.forEach(node => {
                if (!obstacles.has(node.id)) {
                    const heuristic = Math.round(euclideanDistance(node, nodeMap.get(goalId)));
                    const hLabel = document.getElementById(`h-${node.id}`);
                    if (hLabel) {
                        hLabel.textContent = `h=${heuristic}`;
                        hLabel.style.visibility = 'visible';
                    }
                }
            });
            
            stepInfo.textContent = 'Calculating heuristic values for all nodes...';
            await sleep(1000);
            
            // Animate visited nodes
            let visitCount = 0;
            for (const nodeId of result.visitedOrder) {
                if (nodeId === startId || nodeId === goalId) continue;
                
                visitCount++;
                stepInfo.textContent = `Exploring node ${nodeId} (${visitCount} nodes visited)`;
                
                const cell = document.getElementById(`cell-${nodeId}`);
                if (cell) {
                    cell.setAttribute('fill', '#feca57'); // Exploring
                    await sleep(150);
                    cell.setAttribute('fill', '#b2dfdb'); // Visited
                }
                
                // Update score display
                const g = result.gScores.get(nodeId) || 0;
                const f = result.fScores.get(nodeId) || 0;
                const h = f - g;
                scoreContent.innerHTML = `
                    <div><strong>Current: ${nodeId}</strong></div>
                    <div>g(${nodeId}) = ${g.toFixed(1)} (distance from start)</div>
                    <div>h(${nodeId}) = ${h.toFixed(1)} (estimated to goal)</div>
                    <div>f(${nodeId}) = ${f.toFixed(1)} (total score)</div>
                `;
            }
            
            stepInfo.textContent = `Found goal! Visited ${visitCount} nodes. Showing shortest path...`;
            await sleep(1000);
            
            // Animate the final path
            if (result.path) {
                for (let i = 1; i < result.path.length - 1; i++) {
                    const nodeId = result.path[i];
                    const cell = document.getElementById(`cell-${nodeId}`);
                    if (cell) {
                        cell.setAttribute('fill', '#4CAF50');
                        await sleep(200);
                    }
                }
                
                stepInfo.textContent = `Path found! Length: ${result.path.length - 1} steps, Cost: ${result.cost.toFixed(1)}`;
                scoreContent.innerHTML = `
                    <div><strong>Path Complete!</strong></div>
                    <div>Total nodes visited: ${visitCount}</div>
                    <div>Path length: ${result.path.length - 1} steps</div>
                    <div>Path cost: ${result.cost.toFixed(1)}</div>
                    <div>Efficiency: ${((result.path.length - 1) / visitCount * 100).toFixed(1)}%</div>
                `;
            }
        }
        
        // Calculate Euclidean distance heuristic
        function euclideanDistance(nodeA, nodeB) {
            const dx = nodeA.gridX - nodeB.gridX;
            const dy = nodeA.gridY - nodeB.gridY;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // Reset the visualization
        window.resetVisualization = function() {
            document.getElementById('find-btn').disabled = false;
            document.getElementById('score-display').style.display = 'none';
            document.getElementById('step-info').textContent = 'Click "Find Path" to see how A* navigates from start to goal';
            
            // Reset all cells
            nodes.forEach(node => {
                if (!obstacles.has(node.id)) {
                    const cell = document.getElementById(`cell-${node.id}`);
                    if (cell) {
                        cell.setAttribute('fill', node.id === startId ? '#ff9800' : 
                                                 node.id === goalId ? '#f44336' : '#e0e0e0');
                    }
                    
                    // Hide heuristic labels
                    const hLabel = document.getElementById(`h-${node.id}`);
                    if (hLabel) {
                        hLabel.style.visibility = 'hidden';
                    }
                }
            });
        }
        
        // Code toggle functionality
        document.getElementById('code-toggle').addEventListener('click', function() {
            const codeContent = document.getElementById('code-content');
            const toggle = document.getElementById('code-toggle');
            
            if (codeContent.classList.contains('collapsed')) {
                codeContent.classList.remove('collapsed');
                toggle.textContent = 'Hide Code ▲';
            } else {
                codeContent.classList.add('collapsed');
                toggle.textContent = 'Show Code ▼';
            }
        });
        
        // Helper sleep function
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        // Initialize on load
        window.onload = function() {
            initGraph();
            loadCodeExample();
        };
    </script>
</body>
</html>