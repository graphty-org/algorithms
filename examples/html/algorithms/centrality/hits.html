<!DOCTYPE html>
<html lang="en">
<head>
    <!-- MANDATORY: Eruda Mobile Console (exact code) -->
    <script src="https://cdn.jsdelivr.net/npm/eruda@3/eruda.min.js"></script>
    <script>
      if (typeof eruda !== "undefined") {
        eruda.init();
        if (/mobile|android|ios|iphone|ipad|ipod/i.test(navigator.userAgent.toLowerCase())) {
          eruda.show();
        }
      }
    </script>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HITS Algorithm - Simple Visual Explanation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <style>
        /* MANDATORY STYLES - DO NOT MODIFY */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5; /* Light gray background */
        }
        
        h1 {
            color: #2c5aa0; /* Blue header */
            text-align: center;
        }
        
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        #graph {
            width: 100%;
            height: 400px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        button {
            background: #4CAF50; /* Green button */
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
        }
        
        .explanation {
            background: #e8f0fe;
            border-left: 4px solid #2c5aa0;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        /* Additional algorithm-specific styles */
        .back-link {
            text-decoration: none;
            color: #2c5aa0;
            display: inline-block;
            margin-bottom: 20px;
            font-weight: 500;
        }
        
        .back-link:hover {
            text-decoration: underline;
        }
        
        .intro {
            margin-bottom: 20px;
        }
        
        .intro p {
            margin: 10px 0;
            line-height: 1.6;
        }
        
        .intro strong {
            color: #333;
        }
        
        .hits-info {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .hits-stat {
            text-align: center;
            flex: 1;
            min-width: 100px;
        }
        
        .hits-stat .value {
            font-size: 20px;
            font-weight: bold;
            color: #2c5aa0;
        }
        
        .hits-stat .label {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
        }
        
        .step-info {
            margin: 20px 0;
            padding: 15px;
            background: #f0f7ff;
            border-radius: 6px;
            font-size: 16px;
            text-align: center;
        }
        
        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        
        .algorithm-settings {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .setting-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }
        
        .setting-group label {
            font-size: 14px;
            color: #666;
        }
        
        .setting-group input[type="range"] {
            width: 120px;
        }
        
        .setting-group span {
            font-weight: bold;
            color: #2c5aa0;
            font-size: 12px;
        }
        
        .explanation h3 {
            color: #2c5aa0;
            margin-top: 0;
        }
        
        .code-section {
            margin-top: 30px;
            border-top: 1px solid #e0e0e0;
            padding-top: 20px;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .code-header h3 {
            margin: 0;
            color: #2c5aa0;
        }
        
        .code-toggle {
            background: none;
            border: 1px solid #2c5aa0;
            color: #2c5aa0;
            padding: 6px 12px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
        }
        
        .code-toggle:hover {
            background: #2c5aa0;
            color: white;
        }
        
        .code-content {
            background: #f8f9fa;
            border-radius: 6px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .code-content.collapsed {
            max-height: 0;
        }
        
        pre {
            margin: 0;
            overflow-x: auto;
        }
        
        text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        /* Node styling */
        .node-text {
            font-size: 12px;
            font-weight: bold;
            fill: white;
            text-anchor: middle;
            dominant-baseline: central;
        }
        
        .score-text {
            font-size: 9px;
            fill: #333;
            text-anchor: middle;
            dominant-baseline: central;
        }
        
        .hub-score {
            fill: #e91e63;
        }
        
        .auth-score {
            fill: #3f51b5;
        }
        
        .iteration-info {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            font-size: 14px;
            text-align: center;
        }
        
        .view-toggle {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }
        
        .view-btn {
            background: #e0e0e0;
            color: #333;
            border: none;
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .view-btn.active {
            background: #2c5aa0;
            color: white;
        }
        
        .view-btn:hover {
            background: #2c5aa0;
            color: white;
        }
        
        /* Arrow styles */
        .arrow {
            marker-end: url(#arrowhead);
        }
        
        .node-border {
            stroke-width: 3;
        }
    </style>
</head>
<body>
    <a href="../../index.html" class="back-link">‚Üê Back to Examples</a>
    
    <h1>HITS Algorithm Explained</h1>
    
    <div class="container">
        <div class="intro">
            <p><strong>Like a popularity contest with two awards - Best Pointer (Hub) and Most Pointed-To (Authority)!</strong></p>
            <p>HITS finds both hub nodes (that point to many valuable pages) and authority nodes (that are pointed to by many hubs). It's like Google's PageRank but with two separate scores.</p>
        </div>
        
        <svg id="graph">
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                        refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#666" />
                </marker>
            </defs>
        </svg>
        
        <div class="view-toggle">
            <button class="view-btn active" id="view-hubs" onclick="setView('hubs')">Hub Scores</button>
            <button class="view-btn" id="view-authorities" onclick="setView('authorities')">Authority Scores</button>
            <button class="view-btn" id="view-combined" onclick="setView('combined')">Combined View</button>
        </div>
        
        <div class="hits-info">
            <div class="hits-stat">
                <div class="value" id="top-hub">-</div>
                <div class="label">Top Hub</div>
            </div>
            <div class="hits-stat">
                <div class="value" id="top-authority">-</div>
                <div class="label">Top Authority</div>
            </div>
            <div class="hits-stat">
                <div class="value" id="iterations-count">0</div>
                <div class="label">Iterations</div>
            </div>
            <div class="hits-stat">
                <div class="value" id="convergence-status">-</div>
                <div class="label">Status</div>
            </div>
        </div>
        
        <div class="iteration-info" id="iteration-info" style="display: none;">
            Iteration <span id="current-iteration">0</span>: <span id="iteration-step">Computing scores...</span>
        </div>
        
        <div class="step-info" id="step-info">Click "Start" to see how HITS works</div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #e91e63"></div>
                <span>High Hub Score</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #3f51b5"></div>
                <span>High Authority Score</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #9c27b0"></div>
                <span>High Both Scores</span>
            </div>
        </div>
        
        <div class="algorithm-settings">
            <div class="setting-group">
                <label for="animation-speed">Animation Speed</label>
                <input type="range" id="animation-speed" min="500" max="3000" value="1500" step="100">
                <span id="speed-value">1.5s</span>
            </div>
        </div>
        
        <div class="controls">
            <button id="start-btn" onclick="startAlgorithm()">Start HITS Algorithm</button>
        </div>
        
        <div class="explanation">
            <h3>Key Concept:</h3>
            <p>HITS solves a mutual reinforcement problem: good hubs point to good authorities, and good authorities are pointed to by good hubs. The algorithm iteratively updates both scores until they stabilize.</p>
            <p><strong>Hub Score:</strong> Sum of authority scores of nodes you point to</p>
            <p><strong>Authority Score:</strong> Sum of hub scores of nodes pointing to you</p>
            <p>Originally designed for web search, it's perfect for finding influential connectors and respected experts in any network.</p>
        </div>
        
        <div class="code-section">
            <div class="code-header">
                <h3>Code Example</h3>
                <button class="code-toggle" id="code-toggle">Hide Code ‚ñ≤</button>
            </div>
            <div class="code-content" id="code-content">
                <pre><code class="language-javascript" id="code-display">Loading code...</code></pre>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    
    <script type="module">
        // Import the algorithm functions
        import { Graph } from './algorithms.js';
        import { hits } from './algorithms.js';
        
        // Load and display the actual code
        async function loadCodeExample() {
            try {
                const response = await fetch('./hits.js');
                const code = await response.text();
                document.getElementById('code-display').textContent = code;
                Prism.highlightElement(document.getElementById('code-display'));
            } catch (error) {
                document.getElementById('code-display').textContent = 
`import { Graph, hits } from '@graphty/algorithms';

// Create a directed graph
const graph = new Graph({ directed: true });

// Add nodes
graph.addNode('A'); // Hub
graph.addNode('B'); // Authority
graph.addNode('C'); // Authority
graph.addNode('D'); // Hub
graph.addNode('E'); // Authority

// Add directed edges (A and D are hubs pointing to authorities)
graph.addEdge('A', 'B');
graph.addEdge('A', 'C');
graph.addEdge('A', 'E');
graph.addEdge('D', 'B');
graph.addEdge('D', 'C');

// Calculate HITS scores
const result = hits(graph, {
    maxIterations: 100,
    tolerance: 1e-6
});

console.log('Hub scores:', result.hubs);
console.log('Authority scores:', result.authorities);`;
                Prism.highlightElement(document.getElementById('code-display'));
            }
        }
        
        // Graph structure for visualization - web-like structure
        const nodes = [
            {id: 'A', x: 150, y: 100, type: 'hub'},     // Hub node
            {id: 'B', x: 100, y: 250, type: 'auth'},    // Authority
            {id: 'C', x: 200, y: 250, type: 'auth'},    // Authority
            {id: 'D', x: 300, y: 250, type: 'auth'},    // Authority
            {id: 'E', x: 450, y: 100, type: 'hub'},     // Another hub
            {id: 'F', x: 400, y: 250, type: 'auth'},    // Authority
            {id: 'G', x: 500, y: 250, type: 'auth'},    // Authority
            {id: 'H', x: 350, y: 350, type: 'mixed'}    // Mixed node
        ];
        
        const edges = [
            // A is a hub pointing to authorities
            {source: 'A', target: 'B'},
            {source: 'A', target: 'C'},
            {source: 'A', target: 'D'},
            
            // E is another hub
            {source: 'E', target: 'D'},
            {source: 'E', target: 'F'},
            {source: 'E', target: 'G'},
            
            // Some cross-links
            {source: 'B', target: 'H'},
            {source: 'C', target: 'H'},
            {source: 'H', target: 'F'},
            {source: 'H', target: 'G'}
        ];
        
        // Create graph for algorithm
        function createGraph() {
            const graph = new Graph({ directed: true });
            
            // Add nodes
            nodes.forEach(node => graph.addNode(node.id));
            
            // Add edges
            edges.forEach(edge => graph.addEdge(edge.source, edge.target));
            
            return graph;
        }
        
        // Animation state
        let isAnimating = false;
        let hubScores = new Map();
        let authorityScores = new Map();
        let animationSpeed = 1500;
        let currentView = 'hubs';
        
        // Initialize graph visualization
        function initGraph() {
            const svg = document.getElementById('graph');
            
            // Clear existing content except defs
            const defs = svg.querySelector('defs');
            svg.innerHTML = '';
            if (defs) svg.appendChild(defs);
            
            // Draw edges with arrows
            edges.forEach(edge => {
                const sourceNode = nodes.find(n => n.id === edge.source);
                const targetNode = nodes.find(n => n.id === edge.target);
                
                // Calculate arrow position (edge of target circle)
                const dx = targetNode.x - sourceNode.x;
                const dy = targetNode.y - sourceNode.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const unitX = dx / dist;
                const unitY = dy / dist;
                const radius = 25;
                
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', sourceNode.x + unitX * radius);
                line.setAttribute('y1', sourceNode.y + unitY * radius);
                line.setAttribute('x2', targetNode.x - unitX * radius);
                line.setAttribute('y2', targetNode.y - unitY * radius);
                line.setAttribute('stroke', '#666');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('class', 'arrow');
                svg.appendChild(line);
            });
            
            // Draw nodes
            nodes.forEach(node => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('id', `node-group-${node.id}`);
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', node.x);
                circle.setAttribute('cy', node.y);
                circle.setAttribute('r', '25');
                circle.setAttribute('fill', '#e0e0e0');
                circle.setAttribute('stroke', '#333');
                circle.setAttribute('stroke-width', '2');
                circle.setAttribute('id', `node-${node.id}`);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', node.x);
                text.setAttribute('y', node.y - 8);
                text.setAttribute('class', 'node-text');
                text.textContent = node.id;
                
                const hubText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                hubText.setAttribute('x', node.x - 12);
                hubText.setAttribute('y', node.y + 8);
                hubText.setAttribute('class', 'score-text hub-score');
                hubText.setAttribute('id', `hub-${node.id}`);
                hubText.textContent = 'H:0.00';
                
                const authText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                authText.setAttribute('x', node.x + 12);
                authText.setAttribute('y', node.y + 8);
                authText.setAttribute('class', 'score-text auth-score');
                authText.setAttribute('id', `auth-${node.id}`);
                authText.textContent = 'A:0.00';
                
                g.appendChild(circle);
                g.appendChild(text);
                g.appendChild(hubText);
                g.appendChild(authText);
                svg.appendChild(g);
            });
            
            // Initialize UI
            updateSpeedDisplay();
            loadCodeExample();
            
            // Code toggle functionality
            document.getElementById('code-toggle').addEventListener('click', function() {
                const codeContent = document.getElementById('code-content');
                const toggle = document.getElementById('code-toggle');
                
                if (codeContent.classList.contains('collapsed')) {
                    codeContent.classList.remove('collapsed');
                    codeContent.style.maxHeight = codeContent.scrollHeight + 'px';
                    toggle.textContent = 'Hide Code ‚ñ≤';
                } else {
                    codeContent.classList.add('collapsed');
                    codeContent.style.maxHeight = '0';
                    toggle.textContent = 'Show Code ‚ñº';
                }
            });
            
            // Initially show code
            const codeContent = document.getElementById('code-content');
            codeContent.style.maxHeight = codeContent.scrollHeight + 'px';
        }
        
        // Update speed display
        function updateSpeedDisplay() {
            const speed = document.getElementById('animation-speed').value;
            document.getElementById('speed-value').textContent = (speed / 1000).toFixed(1) + 's';
            animationSpeed = parseInt(speed);
        }
        
        // Event listener for settings
        document.getElementById('animation-speed').addEventListener('input', updateSpeedDisplay);
        
        // Get color based on score and view
        function getScoreColor(hubScore, authScore, view) {
            if (view === 'hubs') {
                const intensity = Math.min(hubScore * 2, 1);  // Scale for visibility
                const r = Math.round(233 + (233 - 233) * intensity);  // Pink/red for hubs
                const g = Math.round(30 + (30 - 30) * intensity);
                const b = Math.round(99 + (99 - 99) * intensity);
                return `rgb(${r}, ${g}, ${b})`;
            } else if (view === 'authorities') {
                const intensity = Math.min(authScore * 2, 1);  // Scale for visibility
                const r = Math.round(63 + (63 - 63) * intensity);   // Blue for authorities
                const g = Math.round(81 + (81 - 81) * intensity);
                const b = Math.round(181 + (181 - 181) * intensity);
                return `rgb(${r}, ${g}, ${b})`;
            } else { // combined
                const hubIntensity = Math.min(hubScore * 2, 1);
                const authIntensity = Math.min(authScore * 2, 1);
                const combined = (hubIntensity + authIntensity) / 2;
                const r = Math.round(156 + (156 - 156) * combined);  // Purple for combined
                const g = Math.round(39 + (39 - 39) * combined);
                const b = Math.round(176 + (176 - 176) * combined);
                return `rgb(${r}, ${g}, ${b})`;
            }
        }
        
        // Set view mode
        window.setView = function(view) {
            currentView = view;
            
            // Update buttons
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`view-${view}`).classList.add('active');
            
            // Update visualization
            updateVisualization(hubScores, authorityScores);
        };
        
        // Update visualization with current scores
        function updateVisualization(hubs, authorities, iteration = null) {
            // Update nodes
            nodes.forEach(node => {
                const hubScore = hubs.get(node.id) || 0;
                const authScore = authorities.get(node.id) || 0;
                
                const circle = document.getElementById(`node-${node.id}`);
                const hubText = document.getElementById(`hub-${node.id}`);
                const authText = document.getElementById(`auth-${node.id}`);
                
                if (circle && hubText && authText) {
                    circle.setAttribute('fill', getScoreColor(hubScore, authScore, currentView));
                    hubText.textContent = `H:${hubScore.toFixed(2)}`;
                    authText.textContent = `A:${authScore.toFixed(2)}`;
                }
            });
            
            // Find top nodes
            let topHub = { node: '-', score: 0 };
            let topAuth = { node: '-', score: 0 };
            
            nodes.forEach(node => {
                const hubScore = hubs.get(node.id) || 0;
                const authScore = authorities.get(node.id) || 0;
                
                if (hubScore > topHub.score) {
                    topHub = { node: node.id, score: hubScore };
                }
                if (authScore > topAuth.score) {
                    topAuth = { node: node.id, score: authScore };
                }
            });
            
            document.getElementById('top-hub').textContent = topHub.node;
            document.getElementById('top-authority').textContent = topAuth.node;
            
            if (iteration !== null) {
                document.getElementById('current-iteration').textContent = iteration;
                document.getElementById('iteration-info').style.display = 'block';
            }
        }
        
        // Animate HITS algorithm
        async function animateHITS() {
            const graph = createGraph();
            const maxIterations = 15;
            const tolerance = 1e-6;
            
            // Initialize scores
            let currentHubs = new Map();
            let currentAuthorities = new Map();
            let previousHubs = new Map();
            let previousAuthorities = new Map();
            
            const initialValue = 1.0 / Math.sqrt(nodes.length);
            nodes.forEach(node => {
                currentHubs.set(node.id, initialValue);
                currentAuthorities.set(node.id, initialValue);
            });
            
            updateVisualization(currentHubs, currentAuthorities);
            document.getElementById('step-info').textContent = 'Starting with uniform hub and authority scores...';
            await new Promise(resolve => setTimeout(resolve, animationSpeed));
            
            // Iterative computation
            let converged = false;
            let iteration = 0;
            
            for (iteration = 1; iteration <= maxIterations && !converged; iteration++) {
                previousHubs = new Map(currentHubs);
                previousAuthorities = new Map(currentAuthorities);
                
                document.getElementById('iterations-count').textContent = iteration;
                document.getElementById('iteration-step').textContent = 'Updating authority scores...';
                
                // Update authority scores
                const newAuthorities = new Map();
                for (const node of nodes) {
                    let authorityScore = 0;
                    const inNeighbors = Array.from(graph.inNeighbors(node.id));
                    
                    // Highlight incoming edges
                    edges.forEach(edge => {
                        if (edge.target === node.id) {
                            // Highlight the edge briefly
                        }
                    });
                    
                    for (const inNeighbor of inNeighbors) {
                        authorityScore += previousHubs.get(inNeighbor.toString()) || 0;
                    }
                    
                    newAuthorities.set(node.id, authorityScore);
                }
                
                await new Promise(resolve => setTimeout(resolve, animationSpeed / 3));
                
                document.getElementById('iteration-step').textContent = 'Updating hub scores...';
                
                // Update hub scores
                const newHubs = new Map();
                for (const node of nodes) {
                    let hubScore = 0;
                    const outNeighbors = Array.from(graph.outNeighbors(node.id));
                    
                    for (const outNeighbor of outNeighbors) {
                        hubScore += previousAuthorities.get(outNeighbor.toString()) || 0;
                    }
                    
                    newHubs.set(node.id, hubScore);
                }
                
                await new Promise(resolve => setTimeout(resolve, animationSpeed / 3));
                
                // Normalize scores
                let authNorm = 0;
                for (const value of newAuthorities.values()) {
                    authNorm += value * value;
                }
                authNorm = Math.sqrt(authNorm);
                
                if (authNorm > 0) {
                    for (const [nodeId, value] of newAuthorities) {
                        newAuthorities.set(nodeId, value / authNorm);
                    }
                }
                
                let hubNorm = 0;
                for (const value of newHubs.values()) {
                    hubNorm += value * value;
                }
                hubNorm = Math.sqrt(hubNorm);
                
                if (hubNorm > 0) {
                    for (const [nodeId, value] of newHubs) {
                        newHubs.set(nodeId, value / hubNorm);
                    }
                }
                
                currentAuthorities = newAuthorities;
                currentHubs = newHubs;
                
                // Check for convergence
                let maxDiff = 0;
                for (const [nodeId, value] of currentHubs) {
                    const prevValue = previousHubs.get(nodeId) || 0;
                    const diff = Math.abs(value - prevValue);
                    maxDiff = Math.max(maxDiff, diff);
                }
                for (const [nodeId, value] of currentAuthorities) {
                    const prevValue = previousAuthorities.get(nodeId) || 0;
                    const diff = Math.abs(value - prevValue);
                    maxDiff = Math.max(maxDiff, diff);
                }
                
                updateVisualization(currentHubs, currentAuthorities, iteration);
                
                if (maxDiff < tolerance) {
                    converged = true;
                    document.getElementById('convergence-status').textContent = 'Converged';
                    document.getElementById('step-info').textContent = `Converged after ${iteration} iterations!`;
                } else {
                    document.getElementById('step-info').textContent = `Iteration ${iteration}: Scores are stabilizing...`;
                }
                
                await new Promise(resolve => setTimeout(resolve, animationSpeed / 3));
            }
            
            if (!converged) {
                document.getElementById('convergence-status').textContent = 'Max Iter';
                document.getElementById('step-info').textContent = `Reached maximum iterations (${maxIterations})`;
            }
            
            document.getElementById('iteration-info').style.display = 'none';
            hubScores = currentHubs;
            authorityScores = currentAuthorities;
        }
        
        // Start algorithm
        window.startAlgorithm = async function() {
            if (isAnimating) return;
            
            const button = document.getElementById('start-btn');
            button.disabled = true;
            button.textContent = 'Running...';
            isAnimating = true;
            
            try {
                // Reset display
                document.getElementById('top-hub').textContent = '-';
                document.getElementById('top-authority').textContent = '-';
                document.getElementById('iterations-count').textContent = '0';
                document.getElementById('convergence-status').textContent = '-';
                document.getElementById('iteration-info').style.display = 'none';
                
                // Run actual algorithm for console output
                const graph = createGraph();
                const result = hits(graph, {
                    maxIterations: 15,
                    tolerance: 1e-6
                });
                console.log('HITS Result:', result);
                
                // Animate the algorithm
                await animateHITS();
                
            } finally {
                button.disabled = false;
                button.textContent = 'Start HITS Algorithm';
                isAnimating = false;
            }
        };
        
        // Initialize on load
        window.onload = initGraph;
    </script>
</body>
</html>