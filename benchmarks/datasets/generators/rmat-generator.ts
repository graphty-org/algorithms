import { GraphImpl } from '../../benchmark-graph'

/**
 * Generate RMAT (Recursive Matrix) graphs
 * 
 * RMAT graphs model real-world networks with power-law degree distributions.
 * They're generated by recursively partitioning an adjacency matrix into quadrants
 * and probabilistically placing edges.
 * 
 * @param scale - Log2 of the number of vertices (e.g., scale 10 = 1024 vertices)
 * @param edgeFactor - Ratio of edges to vertices
 * @param a - Probability for top-left quadrant (default 0.57)
 * @param b - Probability for top-right quadrant (default 0.19)
 * @param c - Probability for bottom-left quadrant (default 0.19)
 * @param d - Probability for bottom-right quadrant (default 0.05)
 */
export function generateRMAT(
  scale: number, 
  edgeFactor: number,
  a = 0.57, 
  b = 0.19, 
  c = 0.19, 
  d = 0.05
): GraphImpl {
  // Validate probabilities sum to 1
  const probSum = a + b + c + d
  if (Math.abs(probSum - 1.0) > 0.001) {
    throw new Error(`Probabilities must sum to 1, got ${probSum}`)
  }
  
  const vertices = Math.pow(2, scale)
  const numEdges = Math.floor(vertices * edgeFactor)
  
  const metadata = {
    generationAlgorithm: 'RMAT (Recursive Matrix)',
    parameters: {
      scale,
      vertices,
      edgeFactor,
      edges: numEdges,
      probabilities: { a, b, c, d },
      description: 'Power-law degree distribution graph'
    }
  }
  
  const edges: Array<[number, number]> = []
  const adjacencyList: Record<number, number[]> = {}
  
  // Initialize adjacency list
  for (let i = 0; i < vertices; i++) {
    adjacencyList[i] = []
  }
  
  // Cumulative probabilities for quadrant selection
  const cumA = a
  const cumB = a + b
  const cumC = a + b + c
  
  // Track edge set to avoid duplicates
  const edgeSet = new Set<string>()
  
  for (let i = 0; i < numEdges; i++) {
    let x1 = 0, y1 = 0
    let x2 = vertices - 1, y2 = vertices - 1
    
    // Recursively partition the adjacency matrix
    while (x1 < x2) {
      const rand = Math.random()
      const midX = Math.floor((x1 + x2) / 2)
      const midY = Math.floor((y1 + y2) / 2)
      
      if (rand < cumA) {
        // Top-left quadrant
        x2 = midX
        y2 = midY
      } else if (rand < cumB) {
        // Top-right quadrant
        x1 = midX + 1
        y2 = midY
      } else if (rand < cumC) {
        // Bottom-left quadrant
        x2 = midX
        y1 = midY + 1
      } else {
        // Bottom-right quadrant
        x1 = midX + 1
        y1 = midY + 1
      }
    }
    
    // Add edge if not self-loop and not duplicate
    if (x1 !== y1) {
      const edgeKey = x1 < y1 ? `${x1}-${y1}` : `${y1}-${x1}`
      if (!edgeSet.has(edgeKey)) {
        edgeSet.add(edgeKey)
        edges.push([x1, y1])
        adjacencyList[x1].push(y1)
        adjacencyList[y1].push(x1)
      }
    }
  }
  
  return {
    vertices: Array.from({ length: vertices }, (_, i) => i),
    edges,
    adjacencyList,
    metadata,
    directed: false,
    weighted: false
  }
}

/**
 * Generate RMAT graph suitable for benchmarking
 * Uses default parameters that create realistic power-law distributions
 */
export function generateRMATBenchmark(vertices: number): GraphImpl {
  // Calculate scale (round up to nearest power of 2)
  const scale = Math.ceil(Math.log2(vertices))
  const actualVertices = Math.pow(2, scale)
  
  // Use edge factor of 16 (typical for social networks)
  const edgeFactor = 16
  
  // Generate RMAT with default parameters
  const graph = generateRMAT(scale, edgeFactor)
  
  // If we need fewer vertices, create a subgraph
  if (vertices < actualVertices) {
    const subgraphEdges = graph.edges.filter(([from, to]) => 
      from < vertices && to < vertices
    )
    
    const subgraphAdjacencyList: Record<number, number[]> = {}
    for (let i = 0; i < vertices; i++) {
      subgraphAdjacencyList[i] = []
    }
    
    subgraphEdges.forEach(([from, to]) => {
      subgraphAdjacencyList[from].push(to)
      subgraphAdjacencyList[to].push(from)
    })
    
    return {
      vertices: Array.from({ length: vertices }, (_, i) => i),
      edges: subgraphEdges,
      adjacencyList: subgraphAdjacencyList,
      metadata: {
        ...graph.metadata,
        parameters: {
          ...graph.metadata.parameters,
          vertices,
          edges: subgraphEdges.length,
          subgraphOf: actualVertices
        }
      },
      directed: false,
      weighted: false
    }
  }
  
  return graph
}